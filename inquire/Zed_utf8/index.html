<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Zed_utf8 (inquire.Zed_utf8)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">inquire</a> &#x00BB; Zed_utf8</nav><h1>Module <code>Zed_utf8</code></h1><p>UTF-8 enoded strings</p><nav class="toc"><ul><li><a href="#validation">Validation</a></li><li><a href="#construction">Construction</a></li><li><a href="#informations">Informations</a></li><li><a href="#comparison">Comparison</a></li><li><a href="#random-access">Random access</a></li><li><a href="#string-manipulation">String manipulation</a></li><li><a href="#tranformation">Tranformation</a></li><li><a href="#text-traversals">Text traversals</a></li><li><a href="#scanning">Scanning</a></li><li><a href="#tests">Tests</a></li><li><a href="#stripping">Stripping</a></li><li><a href="#buffers">Buffers</a></li><li><a href="#escaping">Escaping</a></li><li><a href="#safe-offset-api">Safe offset API</a></li><li><a href="#unsafe-offset-api">Unsafe offset API</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = string</code></dt><dd><p>Type of UTF-8 encoded strings.</p></dd></dl><dl><dt class="spec exception" id="exception-Invalid"><a href="#exception-Invalid" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Invalid</span> <span class="keyword">of</span> string * string</code></dt><dd><p><code>Invalid(error, text)</code> Exception raised when an invalid UTF-8 encoded string is encountered. <code>text</code> is the faulty text and <code>error</code> is a description of the first error in <code>text</code>.</p></dd></dl><dl><dt class="spec exception" id="exception-Out_of_bounds"><a href="#exception-Out_of_bounds" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Out_of_bounds</span></code></dt><dd><p>Exception raised when trying to access a character which is outside the bounds of a string.</p></dd></dl><section><header><h6 id="validation"><a href="#validation" class="anchor"></a>Validation</h6></header><dl><dt class="spec type" id="type-check_result"><a href="#type-check_result" class="anchor"></a><code><span class="keyword">type</span> check_result</code><code> = </code><table class="variant"><tr id="type-check_result.Correct" class="anchored"><td class="def constructor"><a href="#type-check_result.Correct" class="anchor"></a><code>| </code><code><span class="constructor">Correct</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>The string is correctly UTF-8 encoded, and the paramter is the length of the string.</p></td></tr><tr id="type-check_result.Message" class="anchored"><td class="def constructor"><a href="#type-check_result.Message" class="anchor"></a><code>| </code><code><span class="constructor">Message</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>The string is invalid and the parameter is an error message.</p></td></tr></table></dt><dd><p>Result of cheking a string for correct UTF-8.</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-check_result">check_result</a></code></dt><dd><p><code>check str</code> checks that <code>str</code> is a valid UTF-8 encoded string.</p></dd></dl><dl><dt class="spec value" id="val-validate"><a href="#val-validate" class="anchor"></a><code><span class="keyword">val</span> validate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Same as check but raises an exception in case the argument is not a valid text, otherwise returns the length of the string.</p></dd></dl><dl><dt class="spec value" id="val-next_error"><a href="#val-next_error" class="anchor"></a><code><span class="keyword">val</span> next_error : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int * int * string</code></dt><dd><p><code>next_error str ofs</code> returns <code>(ofs', count, msg)</code> where <code>ofs'</code> is the offset of the start of the first invalid sequence after <code>ofs</code> (inclusive) in <code>str</code>, <code>count</code> is the number of unicode character between <code>ofs</code> and <code>ofs'</code> (exclusive) and <code>msg</code> is an error message. If there is no error until the end of string then <code>ofs</code> is <code>String.length str</code> and <code>msg</code> is the empty string.</p></dd></dl></section><section><header><h6 id="construction"><a href="#construction" class="anchor"></a>Construction</h6></header><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : Stdlib.Uchar.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>singleton ch</code> creates a string of length 1 containing only the given character.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> Stdlib.Uchar.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make n ch</code> creates a string of length <code>n</code> filled with <code>ch</code>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> Stdlib.Uchar.t)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init n f</code> returns the contenation of <code>singleton (f 0)</code>, <code>singleton (f 1)</code>, ..., <code>singleton (f (n - 1))</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_init"><a href="#val-rev_init" class="anchor"></a><code><span class="keyword">val</span> rev_init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> Stdlib.Uchar.t)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_init n f</code> returns the contenation of <code>singleton (f (n -
      1))</code>, ..., <code>singleton (f 1)</code>, <code>singleton (f 0)</code>.</p></dd></dl></section><section><header><h6 id="informations"><a href="#informations" class="anchor"></a>Informations</h6></header><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the length of the given string.</p></dd></dl></section><section><header><h6 id="comparison"><a href="#comparison" class="anchor"></a>Comparison</h6></header><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Compares two strings (in code point order).</p></dd></dl></section><section><header><h6 id="random-access"><a href="#random-access" class="anchor"></a>Random access</h6></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Uchar.t</code></dt><dd><p><code>get str idx</code> returns the character at index <code>idx</code> in <code>str</code>.</p></dd></dl></section><section><header><h6 id="string-manipulation"><a href="#string-manipulation" class="anchor"></a>String manipulation</h6></header><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sub str ofs len</code> Returns the sub-string of <code>str</code> starting at <code>ofs</code> and of length <code>len</code>.</p></dd></dl><dl><dt class="spec value" id="val-break"><a href="#val-break" class="anchor"></a><code><span class="keyword">val</span> break : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>break str pos</code> returns the sub-strings before and after <code>pos</code> in <code>str</code>. It is more efficient than creating two sub-strings with <a href="index.html#val-sub"><code>sub</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-before"><a href="#val-before" class="anchor"></a><code><span class="keyword">val</span> before : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>before str pos</code> returns the sub-string before <code>pos</code> in <code>str</code></p></dd></dl><dl><dt class="spec value" id="val-after"><a href="#val-after" class="anchor"></a><code><span class="keyword">val</span> after : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>after str pos</code> returns the sub-string after <code>pos</code> in <code>str</code></p></dd></dl><dl><dt class="spec value" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span class="keyword">val</span> insert : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>insert str pos sub</code> inserts <code>sub</code> in <code>str</code> at position <code>pos</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove str pos len</code> removes the <code>len</code> characters at position <code>pos</code> in <code>str</code></p></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>replace str pos len repl</code> replaces the <code>len</code> characters at position <code>pos</code> in <code>str</code> by <code>repl</code>.</p></dd></dl></section><section><header><h6 id="tranformation"><a href="#tranformation" class="anchor"></a>Tranformation</h6></header><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev str</code> reverses all characters of <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat sep l</code> returns the concatenation of all strings of <code>l</code> separated by <code>sep</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_concat"><a href="#val-rev_concat" class="anchor"></a><code><span class="keyword">val</span> rev_concat : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat sep l</code> returns the concatenation of all strings of <code>l</code> in reverse order separated by <code>sep</code>.</p></dd></dl><dl><dt class="spec value" id="val-explode"><a href="#val-explode" class="anchor"></a><code><span class="keyword">val</span> explode : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Stdlib.Uchar.t list</span></code></dt><dd><p><code>explode str</code> returns the list of all characters of <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_explode"><a href="#val-rev_explode" class="anchor"></a><code><span class="keyword">val</span> rev_explode : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Stdlib.Uchar.t list</span></code></dt><dd><p><code>rev_explode str</code> returns the list of all characters of <code>str</code> in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-implode"><a href="#val-implode" class="anchor"></a><code><span class="keyword">val</span> implode : <span>Stdlib.Uchar.t list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>implode l</code> returns the concatenation of all characters of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_implode"><a href="#val-rev_implode" class="anchor"></a><code><span class="keyword">val</span> rev_implode : <span>Stdlib.Uchar.t list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_implode l</code> is the same as <code>implode (List.rev l)</code> but more efficient.</p></dd></dl></section><section><header><h6 id="text-traversals"><a href="#text-traversals" class="anchor"></a>Text traversals</h6></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f str</code> applies <code>f</code> an all characters of <code>str</code> starting from the left.</p></dd></dl><dl><dt class="spec value" id="val-rev_iter"><a href="#val-rev_iter" class="anchor"></a><code><span class="keyword">val</span> rev_iter : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>rev_iter f str</code> applies <code>f</code> an all characters of <code>str</code> starting from the right.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f str acc</code> applies <code>f</code> on all characters of <code>str</code> starting from the left, accumulating a value.</p></dd></dl><dl><dt class="spec value" id="val-rev_fold"><a href="#val-rev_fold" class="anchor"></a><code><span class="keyword">val</span> rev_fold : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>rev_fold f str acc</code> applies <code>f</code> on all characters of <code>str</code> starting from the right, accumulating a value.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> Stdlib.Uchar.t)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f str</code> maps all characters of <code>str</code> with <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val</span> rev_map : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> Stdlib.Uchar.t)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_map f str</code> maps all characters of <code>str</code> with <code>f</code> in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-map_concat"><a href="#val-map_concat" class="anchor"></a><code><span class="keyword">val</span> map_concat : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f str</code> maps all characters of <code>str</code> with <code>f</code> and concatenate the result.</p></dd></dl><dl><dt class="spec value" id="val-rev_map_concat"><a href="#val-rev_map_concat" class="anchor"></a><code><span class="keyword">val</span> rev_map_concat : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_map f str</code> maps all characters of <code>str</code> with <code>f</code> in reverse order and concatenate the result.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter f str</code> filters characters of <code>str</code> with <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_filter"><a href="#val-rev_filter" class="anchor"></a><code><span class="keyword">val</span> rev_filter : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_filter f str</code> filters characters of <code>str</code> with <code>f</code> in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <span>Stdlib.Uchar.t option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f str</code> filters and maps characters of <code>str</code> with <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_filter_map"><a href="#val-rev_filter_map" class="anchor"></a><code><span class="keyword">val</span> rev_filter_map : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <span>Stdlib.Uchar.t option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_filter_map f str</code> filters and maps characters of <code>str</code> with <code>f</code> in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-filter_map_concat"><a href="#val-filter_map_concat" class="anchor"></a><code><span class="keyword">val</span> filter_map_concat : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f str</code> filters and maps characters of <code>str</code> with <code>f</code> and concatenate the result.</p></dd></dl><dl><dt class="spec value" id="val-rev_filter_map_concat"><a href="#val-rev_filter_map_concat" class="anchor"></a><code><span class="keyword">val</span> rev_filter_map_concat : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_filter_map f str</code> filters and maps characters of <code>str</code> with <code>f</code> in reverse order and concatenate the result.</p></dd></dl></section><section><header><h6 id="scanning"><a href="#scanning" class="anchor"></a>Scanning</h6></header><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all f text</code> returns whether all characters of <code>text</code> verify the predicate <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists f text</code> returns whether at least one character of <code>text</code> verify <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>count f text</code> returhs the number of characters of <code>text</code> verifying <code>f</code>.</p></dd></dl></section><section><header><h6 id="tests"><a href="#tests" class="anchor"></a>Tests</h6></header><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains text sub</code> returns whether <code>sub</code> appears in <code>text</code></p></dd></dl><dl><dt class="spec value" id="val-starts_with"><a href="#val-starts_with" class="anchor"></a><code><span class="keyword">val</span> starts_with : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>starts_with text prefix</code> returns <code>true</code> iff <code>s</code> starts with <code>prefix</code>.</p></dd></dl><dl><dt class="spec value" id="val-ends_with"><a href="#val-ends_with" class="anchor"></a><code><span class="keyword">val</span> ends_with : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>ends_with text suffix</code> returns <code>true</code> iff <code>s</code> ends with <code>suffix</code>.</p></dd></dl></section><section><header><h6 id="stripping"><a href="#stripping" class="anchor"></a>Stripping</h6></header><dl><dt class="spec value" id="val-strip"><a href="#val-strip" class="anchor"></a><code><span class="keyword">val</span> strip : <span>?&#8288;predicate:<span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>strip ?predicate text</code> returns <code>text</code> without its firsts and lasts characters that match <code>predicate</code>. <code>predicate</code> default to testing whether the given character has the <code>`White_Space</code> unicode property. For example:</p><pre><code class="ml">strip &quot;\n  foo\n  &quot; = &quot;foo&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-lstrip"><a href="#val-lstrip" class="anchor"></a><code><span class="keyword">val</span> lstrip : <span>?&#8288;predicate:<span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lstrip ?predicate text</code> is the same as <a href="index.html#val-strip"><code>strip</code></a> but it only removes characters at the left of <code>text</code>.</p></dd></dl><dl><dt class="spec value" id="val-rstrip"><a href="#val-rstrip" class="anchor"></a><code><span class="keyword">val</span> rstrip : <span>?&#8288;predicate:<span>(Stdlib.Uchar.t <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lstrip ?predicate text</code> is the same as <a href="index.html#val-strip"><code>strip</code></a> but it only removes characters at the right of <code>text</code>.</p></dd></dl><dl><dt class="spec value" id="val-lchop"><a href="#val-lchop" class="anchor"></a><code><span class="keyword">val</span> lchop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lchop t</code> returns <code>t</code> without is first character. Returns <code>&quot;&quot;</code> if <code>t = &quot;&quot;</code></p></dd></dl><dl><dt class="spec value" id="val-rchop"><a href="#val-rchop" class="anchor"></a><code><span class="keyword">val</span> rchop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rchop t</code> returns <code>t</code> without is last character. Returns <code>&quot;&quot;</code> if <code>t = &quot;&quot;</code>.</p></dd></dl></section><section><header><h6 id="buffers"><a href="#buffers" class="anchor"></a>Buffers</h6></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : Stdlib.Buffer.t <span>&#45;&gt;</span> Stdlib.Uchar.t <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add buf ch</code> is the same as <code>Buffer.add_string buf (singleton
      ch)</code> but is more efficient.</p></dd></dl></section><section><header><h6 id="escaping"><a href="#escaping" class="anchor"></a>Escaping</h6></header><dl><dt class="spec value" id="val-escaped_char"><a href="#val-escaped_char" class="anchor"></a><code><span class="keyword">val</span> escaped_char : Stdlib.Uchar.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>escaped_char ch</code> returns a string containg <code>ch</code> or an escaped version of <code>ch</code> if:</p><ul><li><code>ch</code> is a control character (code &lt; 32)</li><li><code>ch</code> is the character with code 127</li><li><code>ch</code> is a non-ascii, non-alphabetic character</li></ul><p>It uses the syntax <code>\xXX</code>, <code>\uXXXX</code>, <code>\UXXXXXX</code> or a specific escape sequence <code>\n, \r, ...</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_escaped_char"><a href="#val-add_escaped_char" class="anchor"></a><code><span class="keyword">val</span> add_escaped_char : Stdlib.Buffer.t <span>&#45;&gt;</span> Stdlib.Uchar.t <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_escaped_char buf ch</code> is the same as <code>Buffer.add_string buf
      (escaped_char ch)</code> but a bit more efficient.</p></dd></dl><dl><dt class="spec value" id="val-escaped"><a href="#val-escaped" class="anchor"></a><code><span class="keyword">val</span> escaped : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>escaped text</code> escape all characters of <code>text</code> as with <code>escape_char</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_escaped"><a href="#val-add_escaped" class="anchor"></a><code><span class="keyword">val</span> add_escaped : Stdlib.Buffer.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_escaped_char buf text</code> is the same as <code>Buffer.add_string
      buf (escaped text)</code> but a bit more efficient.</p></dd></dl><dl><dt class="spec value" id="val-escaped_string"><a href="#val-escaped_string" class="anchor"></a><code><span class="keyword">val</span> escaped_string : Uutf.encoding <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>escaped_string enc str</code> escape the string <code>str</code> which is encoded with encoding <code>enc</code>. If decoding <code>str</code> with <code>enc</code> fails, it escape all non-printable bytes of <code>str</code> with the syntax <code>\yAB</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_escaped_string"><a href="#val-add_escaped_string" class="anchor"></a><code><span class="keyword">val</span> add_escaped_string : Stdlib.Buffer.t <span>&#45;&gt;</span> Uutf.encoding <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_escaped_char buf enc text</code> is the same as <code>Buffer.add_string buf (escaped_string enc text)</code> but a bit more efficient.</p></dd></dl></section><section><header><h6 id="safe-offset-api"><a href="#safe-offset-api" class="anchor"></a>Safe offset API</h6></header><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>next str ofs</code> returns the offset of the next character in <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-prev"><a href="#val-prev" class="anchor"></a><code><span class="keyword">val</span> prev : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>prev str ofs</code> returns the offset of the previous character in <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val</span> extract : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Uchar.t</code></dt><dd><p><code>extract str ofs</code> returns the code-point at offset <code>ofs</code> in <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-extract_next"><a href="#val-extract_next" class="anchor"></a><code><span class="keyword">val</span> extract_next : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Uchar.t * int</code></dt><dd><p><code>extract_next str ofs</code> returns the code-point at offset <code>ofs</code> in <code>str</code> and the offset of the next character.</p></dd></dl><dl><dt class="spec value" id="val-extract_prev"><a href="#val-extract_prev" class="anchor"></a><code><span class="keyword">val</span> extract_prev : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Uchar.t * int</code></dt><dd><p><code>extract_prev str ofs</code> returns the code-point at the previous offset in <code>str</code> and this offset.</p></dd></dl></section><section><header><h6 id="unsafe-offset-api"><a href="#unsafe-offset-api" class="anchor"></a>Unsafe offset API</h6></header><aside><p>These functions does not check that the given offset is inside the bounds of the given string.</p></aside><dl><dt class="spec value" id="val-unsafe_next"><a href="#val-unsafe_next" class="anchor"></a><code><span class="keyword">val</span> unsafe_next : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_next str ofs</code> returns the offset of the next character in <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_prev"><a href="#val-unsafe_prev" class="anchor"></a><code><span class="keyword">val</span> unsafe_prev : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_prev str ofs</code> returns the offset of the previous character in <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_extract"><a href="#val-unsafe_extract" class="anchor"></a><code><span class="keyword">val</span> unsafe_extract : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Uchar.t</code></dt><dd><p><code>unsafe_extract str ofs</code> returns the code-point at offset <code>ofs</code> in <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_extract_next"><a href="#val-unsafe_extract_next" class="anchor"></a><code><span class="keyword">val</span> unsafe_extract_next : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Uchar.t * int</code></dt><dd><p><code>unsafe_extract_next str ofs</code> returns the code-point at offset <code>ofs</code> in <code>str</code> and the offset the next character.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_extract_prev"><a href="#val-unsafe_extract_prev" class="anchor"></a><code><span class="keyword">val</span> unsafe_extract_prev : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Stdlib.Uchar.t * int</code></dt><dd><p><code>unsafe_extract_prev str ofs</code> returns the code-point at the previous offset in <code>str</code> and this offset.</p></dd></dl></section></div></body></html>